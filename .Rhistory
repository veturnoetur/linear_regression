image.plot(simResult1, col = colPalette, legend.only = TRUE,
legend.width = 1, breaks = breaks, lab.breaks = round(breaks, 2),
legend.args = list(text = 'sediment deposition height [m]', side = 4, font = 2, line = 2.5, cex = 0.8))
plot(depExtentSHP, add = TRUE) # add = TRUE overlays one layer over the other
colPalette <- terrain.colors(7)
breaks <- seq(0.0, 5.0, length.out = length(colPalette)+1)
plot(simResult1, legend = FALSE, axes = TRUE,
col = terrain.colors(7),
breaks = breaks,
main = "Better performing simulation result\nrun53_H2_2\n",
xlab = "UTM westing Coordinate",
ylab = "UTM northing Coordinate")
library(fields)
image.plot(simResult1, col = colPalette, legend.only = TRUE,
legend.width = 1, breaks = breaks, lab.breaks = round(breaks, 2),
legend.args = list(text = 'sediment deposition height [m]', side = 4, font = 2, line = 2.5, cex = 2))
plot(depExtentSHP, add = TRUE) # add = TRUE overlays one layer over the other
colPalette <- terrain.colors(7)
breaks <- seq(0.0, 5.0, length.out = length(colPalette)+1)
plot(simResult1, legend = FALSE, axes = TRUE,
col = terrain.colors(7),
breaks = breaks,
main = "Better performing simulation result\nrun53_H2_2\n",
xlab = "UTM westing Coordinate",
ylab = "UTM northing Coordinate")
library(fields)
image.plot(simResult1, col = colPalette, legend.only = TRUE,
legend.width = 1, breaks = breaks, lab.breaks = round(breaks, 2),
legend.args = list(text = 'sediment deposition height [m]', side = 4, font = 2, line = 2.5, cex = 0.5))
plot(depExtentSHP, add = TRUE) # add = TRUE overlays one layer over the other
colPalette <- terrain.colors(7)
# breaks <- seq(0.0, 5.0, length.out = length(colPalette)+1)
breaks <- c(0.0, 0.1, 0.5, 1.0, 1.5, 2.0, 5.0)
plot(simResult1, legend = FALSE, axes = TRUE,
col = terrain.colors(7),
breaks = breaks,
main = "Better performing simulation result\nrun53_H2_2\n",
xlab = "UTM westing Coordinate",
ylab = "UTM northing Coordinate")
library(fields)
image.plot(simResult1, col = colPalette, legend.only = TRUE,
legend.width = 1, breaks = breaks, lab.breaks = round(breaks, 2),
legend.args = list(text = 'sediment deposition height [m]', side = 4, font = 2, line = 2.5, cex = 0.75))
# construct a list of arguments used for the colour table
colPalette <- terrain.colors(7)
# breaks <- seq(0.0, 5.0, length.out = length(colPalette)+1)
breaks <- c(0.00, 0.10, 0.50, 1.00, 1.50, 2.00, 5.00)
plot(simResult1, legend = FALSE, axes = TRUE,
col = terrain.colors(7),
breaks = breaks,
main = "Better performing simulation result\nrun53_H2_2\n",
xlab = "UTM westing Coordinate",
ylab = "UTM northing Coordinate")
library(fields)
image.plot(simResult1, col = colPalette, legend.only = TRUE,
legend.width = 1, breaks = breaks, lab.breaks = round(breaks, 2),
legend.args = list(text = 'sediment deposition height [m]', side = 4, font = 2, line = 2.5, cex = 0.75))
colPalette <- terrain.colors(7)
# breaks <- seq(0.0, 5.0, length.out = length(colPalette)+1)
breaks <- c(0.00, 0.10, 0.50, 1.00, 1.50, 2.00, 2.50, 5.00)
plot(simResult1, legend = FALSE, axes = TRUE,
col = terrain.colors(7),
breaks = breaks,
main = "Better performing simulation result\nrun53_H2_2\n",
xlab = "UTM westing Coordinate",
ylab = "UTM northing Coordinate")
library(fields)
image.plot(simResult1, col = colPalette, legend.only = TRUE,
legend.width = 1, breaks = breaks, lab.breaks = round(breaks, 2),
legend.args = list(text = 'sediment deposition height [m]', side = 4, font = 2, line = 2.5, cex = 0.75))
plot(depExtentSHP, add = TRUE) # add = TRUE overlays one layer over the other
simResult1 <- raster("F:/_data science references/_visualization/betterResult/run53_H2_2FINALDEP.OUT_NEW.asc")
# load shapefile that contains the observed sediment deposition extent
depExtentSHP <- readOGR("F:/_data science references/_visualization/_deposition extent", "extent")
# check if the bounding boxes of both layers are equivalent
bbox(simResult1)
bbox(depExtentSHP)
# plot layers in a stack
# construct a list of arguments used for the colour table
colPalette <- terrain.colors(7)
# breaks <- seq(0.0, 5.0, length.out = length(colPalette)+1)
breaks <- c(0.00, 0.10, 0.50, 1.00, 1.50, 2.00, 2.50, 5.00)
plot(simResult1, legend = FALSE, axes = TRUE,
col = terrain.colors(7),
breaks = breaks,
main = "Better performing simulation result\nrun53_H2_2\n",
xlab = "UTM westing Coordinate",
ylab = "UTM northing Coordinate")
library(fields)
image.plot(simResult1, col = colPalette, legend.only = TRUE,
legend.width = 1, breaks = breaks, lab.breaks = round(breaks, 2),
legend.args = list(text = 'sediment deposition height [m]', side = 4, font = 2, line = 2.5, cex = 0.75))
plot(depExtentSHP, add = TRUE) # add = TRUE overlays one layer over the other
colPalette <- terrain.colors(7)
# breaks <- seq(0.0, 5.0, length.out = length(colPalette)+1)
breaks <- c(0.00, 0.10, 0.50, 1.00, 1.50, 2.00, 2.50, 5.00)
plot(simResult1, legend = FALSE, axes = TRUE,
col = terrain.colors(7),
breaks = breaks,
main = "Better performing simulation result\nrun53_H2_2\n",
xlab = "UTM westing Coordinate",
ylab = "UTM northing Coordinate")
library(fields)
image.plot(simResult1, col = colPalette, legend.only = TRUE,
legend.width = 1, breaks = breaks, lab.breaks = round(breaks, 2),
legend.args = list(text = 'sediment deposition height [m]', side = 4))
plot(depExtentSHP, add = TRUE) # add = TRUE overlays one layer over the other
# plot layers in a stack
# construct a list of arguments used for the colour table
colPalette <- terrain.colors(7)
# breaks <- seq(0.0, 5.0, length.out = length(colPalette)+1)
breaks <- c(0.00, 0.10, 0.50, 1.00, 1.50, 2.00, 2.50, 5.00)
plot(simResult1, legend = FALSE, axes = TRUE,
col = terrain.colors(7),
breaks = breaks,
main = "Better performing simulation result\nrun53_H2_2\n",
xlab = "UTM westing Coordinate",
ylab = "UTM northing Coordinate")
library(fields)
image.plot(simResult1, col = colPalette, legend.only = TRUE,
legend.width = 1, breaks = breaks, lab.breaks = round(breaks, 2),
legend.args = list(text = 'sediment deposition height [m]', side = 4, line = 2.5, cex = 0.75))
plot(depExtentSHP, add = TRUE) # add = TRUE overlays one layer over the other
simResult2 <- raster("F:/_data science references/_visualization/poorResult/run822_I2FINALDEP.OUT_NEW.asc")
# load shapefile that contains the observed sediment deposition extent
depExtentSHP <- readOGR("F:/_data science references/_visualization/_deposition extent", "extent")
# check if the bounding boxes of both layers are equivalent
bbox(simResult2)
bbox(depExtentSHP)
# plot layers in a stack
# construct a list of arguments used for the colour table
colPalette <- terrain.colors(7)
# breaks <- seq(0.0, 5.0, length.out = length(colPalette)+1)
breaks <- c(0.00, 0.10, 0.50, 1.00, 1.50, 2.00, 2.50, 5.00)
plot(simResult2, legend = FALSE, axes = TRUE,
col = terrain.colors(7),
breaks = breaks,
main = "Better performing simulation result\nrun53_H2_2\n",
xlab = "UTM westing Coordinate",
ylab = "UTM northing Coordinate")
library(fields)
image.plot(simResult2, col = colPalette, legend.only = TRUE,
legend.width = 1, breaks = breaks, lab.breaks = round(breaks, 2),
legend.args = list(text = 'sediment deposition height [m]', side = 4, line = 2.5, cex = 0.75))
plot(depExtentSHP, add = TRUE) # add = TRUE overlays one layer over the other
library(colorRampPalette)
install.packages("colorRampPalette")
install.packages("colorRampPalette", dependencies = TRUE)
install.packages("colorRampPalette", dependencies = TRUE, type = "source")
require(colorRampPalette)
# plot layers in a stack
# colour ramp definition
# colPalette <- terrain.colors(7)
colPalette <- colorRamp(c("red", "blue"))
# breaks <- seq(0.0, 5.0, length.out = length(colPalette)+1)
breaks <- c(0.00, 0.10, 0.50, 1.00, 1.50, 2.00, 2.50, 5.00)
plot(simResult2, legend = FALSE, axes = TRUE,
col = terrain.colors(7),
breaks = breaks,
main = "Better performing simulation result\nrun53_H2_2\n",
xlab = "UTM westing Coordinate",
ylab = "UTM northing Coordinate")
library(fields)
image.plot(simResult2, col = colPalette, legend.only = TRUE,
legend.width = 1, breaks = breaks, lab.breaks = round(breaks, 2),
legend.args = list(text = 'sediment deposition height [m]', side = 4, line = 2.5, cex = 0.75))
simResult2 <- raster("F:/_data science references/_visualization/poorResult/run822_I2FINALDEP.OUT_NEW.asc")
# load shapefile that contains the observed sediment deposition extent
depExtentSHP <- readOGR("F:/_data science references/_visualization/_deposition extent", "extent")
# check if the bounding boxes of both layers are equivalent
bbox(simResult2)
bbox(depExtentSHP)
# colour ramp definition
colPalette <- heat.colors(7)
# manually define breaks
breaks <- c(0.00, 0.10, 0.50, 1.00, 1.50, 2.00, 2.50, 5.00)
# plot layers in a stack
plot(simResult2, legend = FALSE, axes = TRUE,
col = terrain.colors(7),
breaks = breaks,
main = "Better performing simulation result\nrun53_H2_2\n",
xlab = "UTM westing Coordinate",
ylab = "UTM northing Coordinate")
library(fields)
image.plot(simResult2, col = colPalette, legend.only = TRUE,
legend.width = 1, breaks = breaks, lab.breaks = round(breaks, 2),
legend.args = list(text = 'sediment deposition height [m]', side = 4, line = 2.5, cex = 0.75))
plot(depExtentSHP, add = TRUE) # add = TRUE overlays one layer over the other
colPalette <- heat.colors(7)
# manually define breaks
breaks <- c(0.00, 0.10, 0.50, 1.00, 1.50, 2.00, 2.50, 5.00)
# plot layers in a stack
plot(simResult2, legend = FALSE, axes = TRUE,
col = colPalette,
breaks = breaks,
main = "Better performing simulation result\nrun53_H2_2\n",
xlab = "UTM westing Coordinate",
ylab = "UTM northing Coordinate")
library(fields)
image.plot(simResult2, col = colPalette, legend.only = TRUE,
legend.width = 1, breaks = breaks, lab.breaks = round(breaks, 2),
legend.args = list(text = 'sediment deposition height [m]', side = 4, line = 2.5, cex = 0.75))
plot(depExtentSHP, add = TRUE) # add = TRUE overlays one layer over the other
simResult2 <- raster("F:/_data science references/_visualization/poorResult/run822_I2FINALDEP.OUT_NEW.asc")
# load shapefile that contains the observed sediment deposition extent
depExtentSHP <- readOGR("F:/_data science references/_visualization/_deposition extent", "extent")
# check if the bounding boxes of both layers are equivalent
bbox(simResult2)
bbox(depExtentSHP)
# colour ramp definition
colPalette <- terrain.colors(7)
# manually define breaks
breaks <- c(0.00, 0.10, 0.50, 1.00, 1.50, 2.00, 2.50, 5.00)
# plot layers in a stack
plot(simResult2, legend = FALSE, axes = TRUE,
col = colPalette,
breaks = breaks,
main = "Better performing simulation result\nrun53_H2_2\n",
xlab = "UTM westing Coordinate",
ylab = "UTM northing Coordinate")
library(fields)
image.plot(simResult2, col = colPalette, legend.only = TRUE,
legend.width = 1, breaks = breaks, lab.breaks = round(breaks, 2),
legend.args = list(text = 'sediment deposition height [m]', side = 4, line = 2.5, cex = 0.75))
plot(depExtentSHP, add = TRUE) # add = TRUE overlays one layer over the other
library(rgdal)
library(raster)
# import raster file containing the better performing simulation result
simResult1 <- raster("F:/_data science references/_visualization/betterResult/run53_H2_2FINALDEP.OUT_NEW.asc")
# load shapefile that contains the observed sediment deposition extent
depExtentSHP <- readOGR("F:/_data science references/_visualization/_deposition extent", "extent")
# check if the bounding boxes of both layers are equivalent
bbox(simResult1)
bbox(depExtentSHP)
# plot layers in a stack
# construct a list of arguments used for the colour table
colPalette <- terrain.colors(7)
# breaks <- seq(0.0, 5.0, length.out = length(colPalette)+1)
breaks <- c(0.00, 0.10, 0.50, 1.00, 1.50, 2.00, 2.50, 5.00)
plot(simResult1, legend = FALSE, axes = TRUE,
col = terrain.colors(7),
breaks = breaks,
main = "Better performing simulation result\nrun53_H2_2\n",
xlab = "UTM westing Coordinate",
ylab = "UTM northing Coordinate")
library(fields)
image.plot(simResult1, col = colPalette, legend.only = TRUE,
legend.width = 1, breaks = breaks, lab.breaks = round(breaks, 2),
legend.args = list(text = 'sediment deposition height [m]', side = 4, line = 2.5, cex = 0.75))
plot(depExtentSHP, add = TRUE) # add = TRUE overlays one layer over the other
simResult2 <- raster("F:/_data science references/_visualization/poorResult/run822_I2FINALDEP.OUT_NEW.asc")
# load shapefile that contains the observed sediment deposition extent
depExtentSHP <- readOGR("F:/_data science references/_visualization/_deposition extent", "extent")
# check if the bounding boxes of both layers are equivalent
bbox(simResult2)
bbox(depExtentSHP)
# colour ramp definition
colPalette <- terrain.colors(7)
# manually define breaks
breaks <- c(0.00, 0.10, 0.50, 1.00, 1.50, 2.00, 2.50, 5.00)
# plot layers in a stack
plot(simResult2, legend = FALSE, axes = TRUE,
col = colPalette,
breaks = breaks,
main = "Better performing simulation result\nrun822_I2\n",
xlab = "UTM westing Coordinate",
ylab = "UTM northing Coordinate")
library(fields)
image.plot(simResult2, col = colPalette, legend.only = TRUE,
legend.width = 1, breaks = breaks, lab.breaks = round(breaks, 2),
legend.args = list(text = 'sediment deposition height [m]', side = 4, line = 2.5, cex = 0.75))
plot(depExtentSHP, add = TRUE) # add = TRUE overlays one layer over the other
library(rgdal)
library(raster)
# import raster file containing the better performing simulation result
simResult1 <- raster("F:/_data science references/_visualization/betterResult/run53_H2_2FINALDEP.OUT_NEW.asc")
# load shapefile that contains the observed sediment deposition extent
depExtentSHP <- readOGR("F:/_data science references/_visualization/_deposition extent", "extent")
# check if the bounding boxes of both layers are equivalent
bbox(simResult1)
bbox(depExtentSHP)
# colour ramp definition
colPalette <- terrain.colors(7)
# manually define breaks
breaks <- c(0.00, 0.10, 0.50, 1.00, 1.50, 2.00, 2.50, 5.00)
# plot layers in a stack
plot(simResult1, legend = FALSE, axes = TRUE,
col = terrain.colors(7),
breaks = breaks,
main = "Better performing simulation result\nrun53_H2_2\n",
xlab = "UTM westing Coordinate",
ylab = "UTM northing Coordinate")
library(fields)
betterResult <- image.plot(simResult1, col = colPalette, legend.only = TRUE,
legend.width = 1, breaks = breaks, lab.breaks = round(breaks, 2),
legend.args = list(text = 'sediment deposition height [m]', side = 4, line = 2.5, cex = 0.75))
refExtent<- plot(depExtentSHP, add = TRUE) # add = TRUE overlays one layer over the other
# save plot to file
png(filename = "F:/_data science references/analysis/betterResult.png")
plot(betterResult, refExtent)
highModel <- lm(sim_sdh ~ sdh, highCompTable)
par(mfrow = c(2,2))
plot(highModel)
plot(highModel)
plot(highModel, par(mfrow = c(2,2)))
highModel <- lm(sim_sdh ~ sdh, highCompTable)
par(mfrow = c(2,2))
plot(highModel)
confint(highModel)
predict(highModel)
residuals(highModel)
rstudent(highModel)
plot(confint(highModel))
highModel <- lm(sim_sdh ~ sdh, highCompTable)
plot(highModel)
highModel2 <- lm(sim_sdh ~ sdh + conf, highCompTable)
plot(highModel2)
lowModel <- lm(sim_sdh ~ sdh, lowCompTable)
plot(lowModel)
setwd("F:/_data science references/_assignments/linear_regression")
##   You might also start by listing the files in your working directory
getwd() # where am I?
setwd("F:/_data science references/_assignments/linear_regression")
##   You might also start by listing the files in your working directory
getwd() # where am I?
list.files("dataSets") # files in the dataSets folder
# read the states data
states.data <- readRDS("dataSets/states.rds")
#get labels
states.info <- data.frame(attributes(states.data)[c("names", "var.labels")])
#look at last few labels
tail(states.info, 8)
# summary of expense and csat columns, all rows
sts.ex.sat <- subset(states.data, select = c("expense", "csat"))
summary(sts.ex.sat)
# correlation between expense and csat
cor(sts.ex.sat)
# scatter plot of expense vs csat
plot(sts.ex.sat)
##   â¢ Linear regression models can be fit with the `lm()' function
##   â¢ For example, we can use `lm' to predict SAT scores based on
##     per-pupal expenditures:
# Fit our regression model
sat.mod <- lm(csat ~ expense, # regression formula
data=states.data) # data set
# Summarize and print the results
summary(sat.mod) # show regression coefficients table
summary(lm(csat ~ expense + percent, data = states.data))
class(sat.mod)
names(sat.mod)
methods(class = class(sat.mod))[1:9]
##   â¢ Use function methods to get more information about the fit
confint(sat.mod)
par(mar = c(4, 4, 2, 2), mfrow = c(1, 2)) #optional
plot(sat.mod, which = c(1, 2)) # "which" argument optional
par(mar = c(4, 4, 2, 2), mfrow = c(1, 2)) #optional
plot(sat.mod, which = c(1, 2)) # "which" argument optional
sat.voting.mod <-  lm(csat ~ expense + house + senate,
data = na.omit(states.data))
sat.mod <- update(sat.mod, data=na.omit(states.data))
# compare using the anova() function
anova(sat.mod, sat.voting.mod)
coef(summary(sat.voting.mod))
setwd("F:/_data science references/_assignments/linear_regression")
# list files in directory
list.files("dataSets") # files in the dataSets folder
states.info <- data.frame(attributes(states.data)[c("names", "var.labels")])
View(states.info)
View(states.info)
setwd("F:/_data science references/_assignments/linear_regression")
# list files in directory
list.files("dataSets") # files in the dataSets folder
# read the states data
states.data <- readRDS("dataSets/states.rds")
# store labels
states.info <- data.frame(attributes(states.data)[c("names", "var.labels")])
# summary of expense and csat columns, all rows
sts.ex.sat <- subset(states.data, select = c("energy", "csat"))
View(sts.ex.sat)
View(sts.ex.sat)
summary(sts.ex.sat)
cor(sts.ex.sat) # correlation between expense and csat
plot(sts.ex.sat)
summary(sts.ex.sat)
str(summary(sts.ex.sat))
plot(sts.ex.sat)
sts.ex.sat <- subset(states.data, select = c("csat", "energy"))
summary(sts.ex.sat) # returns min, max, median values for each column and a count of NA values
cor(sts.ex.sat) # correlation between expense and csat
# scatterplot of data before fitting model
plot(sts.ex.sat)
setwd("F:/_data science references/_assignments/linear_regression")
# list files in directory
list.files("dataSets") # files in the dataSets folder
# read the states data
states.data <- readRDS("dataSets/states.rds")
# store labels
states.info <- data.frame(attributes(states.data)[c("names", "var.labels")])
##   1. Examine/ plot the data before fitting the model
# return a summary of the subset of all records based on the energy and csat columns
sts.ex.sat <- subset(states.data, select = c("metro", "energy"))
summary(sts.ex.sat) # returns min, max, median values for each column and a count of NA values
cor(sts.ex.sat) # correlation between expense and csat
# scatterplot of data before fitting model
plot(sts.ex.sat)
sat.mod <- lm(energy ~ metro, data = states.data)
plot(sat.mod)
summary(sat.mod) # show regression coefficients table
plot(sat.mod)
summary(sat.mod) # show regression coefficients table
sts.ex.sat2 <- subset(states.data, select = c("metro", "region", "energy"))
summary(sts.ex.sat2) # returns min, max, median values for each column and a count of NA values
cor(sts.ex.sat2) # correlation between expense and csat
sts.ex.sat2 <- subset(states.data, select = c("metro", "waste", "energy"))
summary(sts.ex.sat2) # returns min, max, median values for each column and a count of NA values
cor(sts.ex.sat2)
# scatterplot of data before fitting model
plot(sts.ex.sat2)
##   2. Print and interpret the model `summary'
# fit a linear regression model
sat.mod2 <- lm(energy ~ metro + waste, data = states.data)
# Summarize and print the results
summary(sat.mod2) # show regression coefficients table
sts.ex.sat3 <- subset(states.data, select = c("metro", "waste", "density", "energy"))
summary(sts.ex.sat3) # returns min, max, median values for each column and a count of NA values
cor(sts.ex.sat3)
# scatterplot of data before fitting model
plot(sts.ex.sat3)
##   2. Print and interpret the model `summary'
# fit a linear regression model
sat.mod3 <- lm(energy ~ metro + waste, data = states.data)
# Summarize and print the results
summary(sat.mod3) # show regression coefficients table
##   2. Print and interpret the model `summary'
# fit a linear regression model
sat.mod3 <- lm(energy ~ metro + waste + density, data = states.data)
# Summarize and print the results
summary(sat.mod3) # show regression coefficients table
# Multiple R-squared:  0.1253 compared with 0.1154 indicates a slight improvement
sat.expense.by.percent <- lm(csat ~ expense*income,
data=states.data)
#Show the results
coef(summary(sat.expense.by.percent))
str(states.data$region)
states.data$region <- factor(states.data$region)
#Add region to the model
sat.region <- lm(csat ~ region,
data=states.data)
#Show the results
coef(summary(sat.region)) # show regression coefficients table
anova(sat.region) # show ANOVA table
contrasts(states.data$region)
# change the reference group
coef(summary(lm(csat ~ C(region, base=4),
data=states.data)))
# change the coding scheme
coef(summary(lm(csat ~ C(region, contr.helmert),
data=states.data)))
##   Use the /states.rds/ data set. Fit a model predicting energy consumed per capita (energy) from the percentage of residents living in metropolitan areas (metro).
# set the working directory
setwd("F:/_data science references/_assignments/linear_regression")
# list files in directory
list.files("dataSets") # files in the dataSets folder
# read the states data
states.data <- readRDS("dataSets/states.rds")
# store labels
states.info <- data.frame(attributes(states.data)[c("names", "var.labels")])
##   1. Examine/ plot the data before fitting the model
# return a summary of the subset of all records based on the energy and metro columns
metEnergy <- subset(states.data, select = c("metro", "energy"))
summary(metEnergy) # returns min, max, median values for each column and a count of NA values
cor(metEnergy) # correlation between energy and metro
# scatterplot of data before fitting model
plot(metEnergy)
##   2. Print and interpret the model `summary'
# fit a linear regression model
en.mod <- lm(energy ~ metro, data = states.data)
# Summarize and print the results
summary(en.mod) # show regression coefficients table
# Multiple R-squared:  0.1154
plot(en.mod)
metEnergy2 <- subset(states.data, select = c("metro", "waste", "energy"))
summary(metEnergy2) # returns min, max, median values for each column and a count of NA values
cor(metEnergy2)
# scatterplot of data before fitting model
plot(metEnergy2)
##   2. Print and interpret the model `summary'
# fit a linear regression model
en.mod2 <- lm(energy ~ metro + waste, data = states.data)
# Summarize and print the results
summary(en.mod2) # show regression coefficients table
# Multiple R-squared:  0.1253 compared with 0.1154 indicates a slight improvement
metEnergy3 <- subset(states.data, select = c("metro", "waste", "density", "energy"))
summary(metEnergy3) # returns min, max, median values for each column and a count of NA values
cor(metEnergy3)
# scatterplot of data before fitting model
plot(metEnergy3)
##   2. Print and interpret the model `summary'
# fit a linear regression model
en.mod3 <- lm(energy ~ metro + waste + density, data = states.data)
# Summarize and print the results
summary(en.mod3) # show regression coefficients table
en.modInt <- lm(energy ~ metro*density, data = states.data)
# return results of adding the interaction term
coef(summary(en.modInt))
str(states.data$region)
states.data$region <- factor(states.data$region)
# add region to the model
en.modReg <- lm(energy ~ region, data = states.data)
# show the results: regression coefficients and ANOVA tables
coef(summary(en.modReg))
anova(en.modReg)
